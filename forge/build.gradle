plugins {
    id 'net.minecraftforge.gradle'
    id 'org.spongepowered.mixin'
    id 'org.parchmentmc.librarian.forgegradle'
    id 'com.matthewprenger.cursegradle'
}

configurations.create("includedLibraries")
configurations.implementation.extendsFrom configurations.includedLibraries
configurations.includedLibraries.transitive false

def libraryConfigs = new HashSet<org.gradle.api.artifacts.Configuration>();
configurations { configContainer ->
    sourceSets.each { sourceSet ->
        def configName = sourceSet.name == "main" ? "forgeLibrary" : sourceSet.name + "ForgeLibrary";
        def implementationConfigName = sourceSet.name == "main" ? "implementation" : sourceSet.name + "Implementation"

        def libraryConfig = configContainer.maybeCreate(configName)
        def implementationConfig = configContainer.maybeCreate(implementationConfigName)

        implementationConfig.extendsFrom libraryConfig

        libraryConfigs.add(libraryConfig);
    }
}


project.addCoreProject()

project.minecraft.mappings channel: "parchment", version: "${project.parchmentMinecraftVersion}-${project.parchmentVersion}-${project.minecraftVersion}"
project.minecraft.accessTransformer = project(':common').file("accesstransformer.cfg")

project.minecraft.runs { runSpecContainer ->
    client { clientRun ->
        clientRun.workingDirectory project.file('run')
        clientRun.ideaModule "${rootProject.name.toLowerCase()}.${project.name.toLowerCase()}.main"
        clientRun.taskName 'Client'
        clientRun.mods { modsContainer ->
            modsContainer.create(project.modId, {
                source sourceSets.main
                source project(":common").sourceSets.main
                source project(":core").sourceSets.main
            })
        }
    }

    server { serverRun ->
        serverRun.workingDirectory project.file('run')
        serverRun.ideaModule "${rootProject.name.toLowerCase()}.${project.name.toLowerCase()}.main"
        serverRun.taskName 'Server'
        serverRun.mods { modsContainer ->
            modsContainer.create(project.modId, {
                source sourceSets.main
                source project(":common").sourceSets.main
                source project(":core").sourceSets.main
            })
        }
    }

    data { dataRun ->
        dataRun.workingDirectory project.file('run')
        dataRun.ideaModule "${rootProject.name.toLowerCase()}.${project.name.toLowerCase()}.main"
        dataRun.taskName "Data"
        dataRun.args '--mod', "${project.modId.toLowerCase()}",
                '--output', project(":core").file("src/datagen/generated"),
                '--existing', file('src/main/resources/'),
                '--existing', project(":core").file('src/main/resources/'),
                '--existing-mod', 'scena'
        dataRun.mods { modsContainer ->
            modsContainer.create(project.modId, {
                source sourceSets.main
                source project(":common").sourceSets.main
                source project(":core").sourceSets.main
            })
        }
    }

    project.afterEvaluate {
        def paths = new HashSet<String>();
        libraryConfigs.each { config ->
            config.copyRecursive().resolve().collect { it.absolutePath.toString() }.each {path -> paths.add(path)}
        }

        runSpecContainer.each { runSpec ->
            runSpec.lazyToken('minecraft_classpath') {
                paths.join(File.pathSeparator)
            }
        }
    }
}

project.dependencies.minecraft "net.minecraftforge:forge:${project.minecraftVersion}-${project.forgeVersion}"
project.dependencies.annotationProcessor "org.spongepowered:mixin:${project.mixinAnnotationProcessorVersion}:processor"
project.dependencies.includedLibraries fg.deobf("com.communi-suggestu.scena:scena-forge:${project.scenaVersion}") {
    jarJar.pin(it, project.scenaVersion)
    jarJar.ranged(it, buildSupportedVersionRange(project.scenaVersion))
}

project.tasks.processResources.from (project(":common").file("accesstransformer.cfg")) {
    into 'META-INF'
}
setupResourceProcessing(project.tasks.processResources)

////////////////
// IntelliJ Project Import
// The Mixin annotation process does not have an obfuscation source when running through the IntelliJ compiler,
// thus we have to prevent it from being activated as part of importing this Gradle project into IntelliJ.
if (System.getProperty("idea.sync.active") == "true") {
    afterEvaluate {
        tasks.withType(JavaCompile).all {
            it.options.annotationProcessorPath = files()
        }
    }
}

jarJar {
    fromRuntimeConfiguration()
    dependencies {
        include(dependency("com.communi-suggestu.scena:scena-forge"))
    }
}

reobf {
    jarJar {}
}

afterEvaluate {
    tasks.jar.finalizedBy tasks.reobfJar
    tasks.jarJar.finalizedBy tasks.reobfJarJar
    tasks.reobfJarJar.enabled = true
}

tasks.jarJar.archiveClassifier.set("");
tasks.jar.archiveClassifier.set("slim");
tasks.build.dependsOn tasks.jarJar

project.publishToCurseForge(tasks.jarJar)