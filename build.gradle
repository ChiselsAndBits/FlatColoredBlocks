import groovy.json.JsonOutput
import org.apache.tools.ant.filters.ReplaceTokens

project.group = "mod.flatcoloredblocks"
project.version = (System.getenv().containsKey("Version") ? System.getenv("Version") : project.localVersion)

//Configure extension utility methods on all subprojects.
subprojects { Project subProject ->
    subProject.ext.setupEmbeddedPublishing = { MavenPublication mavenPublication ->
        subProject.afterEvaluate { Project evaluatedSubProject ->
            if (evaluatedSubProject.getPlugins().hasPlugin("net.minecraftforge.gradle")) {
                evaluatedSubProject.jarJar.component(mavenPublication)
            }
        }
    }

    subProject.ext.cleanMavenPublication = { MavenPublication mavenPublication ->
        //Replace all deobf dependencies with normal jar references.
        mavenPublication.pom.withXml { XmlProvider xmlProvider ->
            def dependencies = asNode().dependencies
            def allDeps = dependencies.'*';

            // Remove forge, minecraft and ourselves as deps
            allDeps.findAll() { Node el ->
                (el.artifactId.text() == 'forge' && el.groupId.text() == 'net.minecraftforge') ||
                        (el.artifactId.text() == 'joined' && el.groupId.text() == 'net.minecraft') ||
                        (el.groupId.text() == 'com.communi-coresuggestu.scena') ||
                        (el.groupId.text() == 'com.communi-suggestu.saecularia-caudices')
            }.forEach() { el ->
                el.parent().remove(el)
            }

            //remove forgegradle's mapped suffix from versions & set as optional so anyone else doesn't inherit them
            allDeps.findAll() { el ->
                el.version.text().contains('_mapped_')
            }.each { el ->
                def version = el.version
                version.each {
                    it.setValue(it.text().substring(0, it.text().indexOf('_mapped_')))
                }
            }
        }
    }

    subProject.ext.disableCompiling = {
        subProject.tasks.build.enabled = false
        subProject.tasks.jar.enabled = false
        subProject.tasks.processResources.enabled = false
        subProject.tasks.assemble.enabled = false
        subProject.tasks.compileJava.enabled = false
        subProject.tasks.classes.enabled = false
        subProject.tasks.test.enabled = false
        subProject.tasks.testClasses.enabled = false
        subProject.tasks.check.enabled = false
    }

    subProject.ext.disableForgeGradleCompiling = {
        subProject.afterEvaluate { Project evaluatedProject ->
            evaluatedProject.tasks.reobfJar.enabled = false
        }
    }

    subProject.ext.addCoreProject = {
        def coreProject = subProject.project(":core")

        subProject.dependencies.implementation(coreProject) {
            transitive = false
        }

        subProject.tasks.jar.from coreProject.sourceSets.main.output
        subProject.tasks.processResources.from coreProject.sourceSets.main.resources
        subProject.tasks.processResources.inputs.property "version", subProject.version
        subProject.tasks.processResources.duplicatesStrategy = DuplicatesStrategy.EXCLUDE

        if (subProject.getPlugins().hasPlugin("net.minecraftforge.gradle")) {
            subProject.tasks.jarJar.from coreProject.sourceSets.main.output
        }
    }

    subProject.ext.determineNextMajorVersion = { v ->
        def components = v.split("\\.")
        def major = components[0].toInteger()
        return "${major + 1}.0.0".toString()
    }

    subProject.ext.buildSupportedVersionRange = { v ->
        def nextMajorComponent = determineNextMajorVersion(v)
        return "[${v},${nextMajorComponent})".toString()
    }

    subProject.ext.getIdentifiers = {
        def propertiesToExpand = [
                "version"                   : project.version,
                "name"                      : rootProject.name.toString(),
                "id"                        : rootProject.modId.toString(),
                "description"               : (rootProject.description == null ? "" : rootProject.description).toString(),
                "author"                    : rootProject.author.toString(),
                "sources"                   : rootProject.githubUrl.toString(),
                "package"                   : "${rootProject.group}.${subProject.name.toLowerCase()}".toString(),
                "forgeVersion"              : project.forgeVersion,
                "minecraftVersion"          : project.minecraftVersion,
                "supportedScenaVersionRange": buildSupportedVersionRange(project.scenaVersion),
                "scenaVersion"              : project.scenaVersion,
                "fabricVersion"             : project.fabricVersion,
                "fabricLoaderVersion"       : project.fabricLoaderVersion,
        ]

        return propertiesToExpand
    }

    subProject.ext.setupResourceProcessing = { copyTask ->
        copyTask.rename({ fileName ->
            if (fileName != "mixins.json") {
                return fileName
            } else {
                return "${rootProject.name.toLowerCase()}.mixins.json"
            }
        })
        copyTask.filesMatching(["META-INF/mods.toml", "pack.mcmeta", "mixins.json", "${rootProject.name.toLowerCase()}.mixins.json".toString(), "fabric.mod.json"]) {
            filter(ReplaceTokens, tokens: getIdentifiers())
        }
        copyTask.getInputs().properties(getIdentifiers())
    }

    subProject.ext.configureJarManifest = { jar ->
        jar.manifest.attributes([
                'Maven-Artifact'          : "${project.group}:${project.archivesBaseName}:${project.version}",
                "Specification-Title"     : project.name,
                "Specification-Vendor"    : project.author.toString(),
                "Specification-Version"   : project.version,
                "Implementation-Title"    : project.name,
                "Implementation-Version"  : project.version,
                "Implementation-Vendor"   : project.author.toString(),
                "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
                "Automatic-Module-Name"   : project.name,
                "MixinConfigs"            : "${rootProject.name.toLowerCase()}.mixins.json"
        ])
    }

    subProject.ext.publishToCurseForge = { jar ->
        if (System.getenv().containsKey("CURSE_API_KEY")) {
            subProject.curseforge { cf ->
                cf.apiKey = System.getenv("CURSE_API_KEY")

                project { cp ->
                    cp.id = subProject.curseId
                    cp.addGameVersion("Java ${subProject.java.toolchain.languageVersion.get().asInt()}")
                    cp.addGameVersion(subProject.minecraftVersion)
                    cp.changelog = rootProject.file('build/changelog.md')
                    cp.changelogType = 'markdown'
                    cp.releaseType = 'release'

                    subProject.additionalMinecraftVersions.toString().split(";").each { v ->
                        if (!v.trim().isEmpty()) {
                            cp.addGameVersion(v)
                        }
                    }

                    cp.mainArtifact(jar)
                }
            }

            subProject.tasks.curseforge.dependsOn subProject.rootProject.tasks.createChangelog
        }
    }
}

subprojects { subProject ->
    subProject.apply { configure ->
        configure.plugin("idea")
        configure.plugin("java")
        configure.plugin("java-library")
        configure.plugin("maven-publish")
    }

    subProject.archivesBaseName = "${rootProject.name}-${subProject.name}"

    subProject.repositories.mavenLocal()
    subProject.repositories.mavenCentral()
    subProject.repositories.maven {
        name 'LDTTeam - Modding'
        url 'https://ldtteam.jfrog.io/ldtteam/modding/'
    }

    subProject.group = rootProject.group
    subProject.version = rootProject.version

    subProject.java.toolchain.languageVersion.set(JavaLanguageVersion.of(project.javaVersion))

    subProject.tasks.jar.baseName = "${rootProject.name}-${subProject.name}"
    subProject.configureJarManifest(subProject.tasks.jar)
    subProject.tasks.jar.duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    subProject.publishing.repositories.maven {
        name 'InternalDirectory'
        url 'file://' + rootProject.file('repo').getAbsolutePath()
    }

    subProject.dependencies.compileOnly "org.jetbrains:annotations:${project.jetbrainsAnnotationsVersion}"
    subProject.dependencies.testCompileOnly "org.jetbrains:annotations:${project.jetbrainsAnnotationsVersion}"


    subProject.afterEvaluate {
        if (subProject.tasks.build.enabled) {
            subProject.publishing {
                publications {
                    mavenJava(MavenPublication) { pub ->
                        artifactId "${rootProject.name}-${subProject.name}"

                        from subProject.components.java

                        pom {
                            url = subProject.githubUrl
                            licenses {
                                license {
                                    name = 'GNU GENERAL PUBLIC LICENSE Version 3'
                                    url = 'https://www.gnu.org/licenses/gpl-3.0.en.html'
                                }
                            }
                            developers {
                                developer {
                                    id = 'OrionDevelopment'
                                    name = 'Marc Hermans'
                                    email = 'marc.hermans@ldtteam.com'
                                }
                            }
                            scm {
                                connection = subProject.gitUrl
                                developerConnection = subProject.gitConnectUrl
                                url = subProject.projectUrl
                            }
                        }

                        subProject.cleanMavenPublication(pub)
                        subProject.setupEmbeddedPublishing(pub)
                    }
                }
            }
        }
    }
}

task("createChangelog") {
    group = 'publishing'

    doLast {
        def teamCityURL = "https://buildsystem.ldtteam.com/"
        project.rootProject.file("build/changelog.md").parentFile.mkdirs()
        def file = new FileOutputStream(project.rootProject.file("build/changelog.md"))
        def out = new BufferedOutputStream(file)
        def changesXML = new XmlSlurper().parse(teamCityURL + "guestAuth/app/rest/changes?locator=build:(id:" + teamcity["teamcity.build.id"] + ")")

        def changes = changesXML.change
        out << "# ${project.name} Changelog \n"
        out << "## Version: _" + version + "_ \n"

        out << "### Changes: \n"
        if (changes.size() > 0) {
            for (int i = 0; i < changes.size(); i++) {
                def changeDetailsURL = teamCityURL + "guestAuth/app/rest/changes/id:" + changes[i].@id.text()
                def changeDetailsXml = new XmlSlurper().parse(changeDetailsURL)
                def changeComment = changeDetailsXml.comment.text().trim()

                out << "* " + changeComment + "\n"
            }
        } else {
            out << "_No Changes detected!_"
        }

        out.close()
    }
}